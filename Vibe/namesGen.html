<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Генератор Имен: AI & База Данных</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --card-bg: #1e293b;
            --text-color: #f1f5f9;
            --accent-color: #38bdf8;
            --accent-hover: #0ea5e9;
            --secondary-text: #94a3b8;
            --border-color: #334155;
            --success: #4ade80;
            --font-main: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            --font-mono: 'Courier New', Courier, monospace;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
        }

        header {
            padding: 20px;
            background: rgba(30, 41, 59, 0.9);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }

        h1 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .controls-wrapper {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .mode-switcher {
            display: flex;
            background: var(--bg-color);
            border-radius: 8px;
            padding: 4px;
            border: 1px solid var(--border-color);
            width: fit-content;
        }

        .mode-btn {
            background: transparent;
            border: none;
            color: var(--secondary-text);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }

        .mode-btn.active {
            background: var(--card-bg);
            color: var(--accent-color);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            align-items: flex-end;
        }

        @media (min-width: 768px) {
            .controls-grid {
                grid-template-columns: 1fr 1fr 1fr auto;
            }
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 0.85rem;
            color: var(--secondary-text);
            font-weight: 500;
        }

        select, input[type="text"], input[type="number"] {
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.2s;
            width: 100%;
        }

        select:focus, input:focus { border-color: var(--accent-color); }

        .btn {
            padding: 10px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            font-size: 1rem;
            height: 42px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 140px;
        }

        .btn-primary {
            background: var(--accent-color);
            color: #000;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--accent-hover);
            transform: translateY(-1px);
        }

        .btn-primary:disabled {
            background: #475569;
            color: #94a3b8;
            cursor: wait;
        }

        main {
            flex: 1;
            padding: 40px 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .hero-name {
            font-size: clamp(3rem, 10vw, 6rem);
            font-weight: 800;
            text-align: center;
            background: linear-gradient(135deg, #fff 0%, var(--accent-color) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            text-transform: capitalize;
            min-height: 1.2em;
            word-break: break-all;
        }

        .hero-meta {
            color: var(--secondary-text);
            margin-bottom: 40px;
            font-size: 0.95rem;
            text-align: center;
            height: 20px;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px;
            width: 100%;
            max-width: 1000px;
        }

        .name-card {
            background: var(--card-bg);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.1rem;
            border: 1px solid transparent;
            transition: all 0.2s;
            cursor: pointer;
            text-transform: capitalize;
        }

        .name-card:hover {
            border-color: var(--accent-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .loader {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        /* Footer Console */
        .footer-console {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: #000;
            color: #0f0;
            font-family: var(--font-mono);
            font-size: 12px;
            z-index: 1000;
            border-top: 1px solid #333;
            display: flex;
            flex-direction: column;
        }

        .console-header {
            padding: 8px 15px;
            background: #111;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            color: #888;
        }

        #console {
            height: 0;
            overflow-y: auto;
            padding: 0 15px;
            white-space: pre-wrap;
            transition: height 0.3s;
            display: none;
        }

        #console.open { height: 150px; padding: 15px; display: block; }
        
        .status-dot {
            width: 8px;
            height: 8px;
            background: var(--success);
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }
    </style>
</head>
<body>

<header>
    <div class="container">
        <h1>
            <span style="color:var(--accent-color)">⚡</span> ИмяГенератор
        </h1>
        <div class="controls-wrapper">
            <div class="mode-switcher">
                <button class="mode-btn active" onclick="setMode('db')" id="mode-db">База данных</button>
                <button class="mode-btn" onclick="setMode('ai')" id="mode-ai">Нейросеть</button>
            </div>

            <div class="controls-grid">
                <div class="control-group">
                    <label>Тип</label>
                    <select id="datasetSelect" onchange="handleTypeChange()">
                        <option value="names">Люди</option>
                        <option value="pets">Клички животных</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Начинается с</label>
                    <input type="text" id="startsWith" placeholder="Любой" maxlength="3">
                </div>
                <div class="control-group">
                    <label>Мин. длина</label>
                    <input type="number" id="lengthFilter" placeholder="Любая" min="1" max="20">
                </div>
                <div class="control-group">
                    <button class="btn btn-primary" onclick="generate()" id="mainBtn">Сгенерировать</button>
                </div>
            </div>
        </div>
    </div>
</header>

<main>
    <div class="container" style="display:flex; flex-direction:column; align-items:center;">
        <div id="loader" style="display:none; margin-bottom:20px;"><span class="loader"></span></div>
        
        <div id="heroSection">
            <div class="hero-name" id="heroName">...</div>
            <div class="hero-meta" id="heroMeta"></div>
        </div>

        <div class="grid-container" id="nameGrid"></div>
    </div>
</main>

<div class="footer-console">
    <div class="console-header" onclick="toggleConsole()">
        <span><span class="status-dot"></span><span id="statusBar">Готов к работе</span></span>
        <span id="consoleToggleIcon">▲</span>
    </div>
    <div id="console"></div>
</div>

<script>
// ==========================================
// 1. UI & State Logic
// ==========================================
const consoleEl = document.getElementById('console');
const statusEl = document.getElementById('statusBar');
const heroNameEl = document.getElementById('heroName');
const heroMetaEl = document.getElementById('heroMeta');
const nameGridEl = document.getElementById('nameGrid');
const loader = document.getElementById('loader');
const mainBtn = document.getElementById('mainBtn');

let currentMode = 'db'; 
let datasets = { names: [], pets: [] };

// Структура для хранения моделей: names и pets разделены
const models = {
    names: { loaded: false, loading: false, data: null },
    pets:  { loaded: false, loading: false, data: null }
};
let activeModel = null; // Ссылка на текущую активную модель

function setMode(mode) {
    currentMode = mode;
    document.getElementById('mode-db').classList.toggle('active', mode === 'db');
    document.getElementById('mode-ai').classList.toggle('active', mode === 'ai');
    generate();
}

function handleTypeChange() {
    generate();
}

function toggleConsole() {
    consoleEl.classList.toggle('open');
    document.getElementById('consoleToggleIcon').innerText = consoleEl.classList.contains('open') ? '▼' : '▲';
}

function print(text) {
    const div = document.createElement('div');
    div.textContent = `> ${text}`;
    consoleEl.appendChild(div);
    consoleEl.scrollTop = consoleEl.scrollHeight;
}

function setStatus(text) { statusEl.textContent = text; }
function showLoading(show) {
    loader.style.display = show ? 'block' : 'none';
    mainBtn.disabled = show;
}

// ==========================================
// 2. Database Logic
// ==========================================
async function loadDatasets() {
    setStatus("Загрузка баз данных...");
    try {
        const urls = {
            names: 'https://raw.githubusercontent.com/boolkin/html/refs/heads/master/Vibe/microgpt/datasets/names.txt',
            pets: 'https://raw.githubusercontent.com/boolkin/html/refs/heads/master/Vibe/microgpt/datasets/pets.txt'
        };

        const [namesRes, petsRes] = await Promise.all([ fetch(urls.names), fetch(urls.pets) ]);
        const namesText = await namesRes.text();
        const petsText = await petsRes.text();

        datasets.names = namesText.split('\n').map(n => n.trim()).filter(n => n.length > 0);
        datasets.pets = petsText.split('\n').map(n => n.trim()).filter(n => n.length > 0);

        setStatus("Базы загружены");
        print(`Загружено имен: ${datasets.names.length}, кличек: ${datasets.pets.length}`);
    } catch (e) {
        setStatus("Ошибка загрузки данных");
        print("Ошибка: " + e.message);
    }
}

function generateFromDB() {
    const type = document.getElementById('datasetSelect').value;
    const prefix = document.getElementById('startsWith').value.toLowerCase();
    const lengthVal = document.getElementById('lengthFilter').value;
    const minLen = lengthVal ? parseInt(lengthVal) : 0;

    let pool = datasets[type] || [];
    
    if (prefix) pool = pool.filter(n => n.toLowerCase().startsWith(prefix));
    if (minLen > 0) pool = pool.filter(n => n.length >= minLen);

    if (pool.length === 0) {
        heroNameEl.innerText = "Нет результатов";
        heroMetaEl.innerText = "Измените фильтры";
        nameGridEl.innerHTML = "";
        return;
    }

    heroMetaEl.innerText = `Найдено в базе: ${pool.length} совпадений`;

    const shuffled = pool.sort(() => 0.5 - Math.random());
    
    const mainName = shuffled[0];
    heroNameEl.innerText = mainName;

    nameGridEl.innerHTML = "";
    const others = shuffled.slice(1, 21);
    others.forEach(name => {
        const card = document.createElement('div');
        card.className = 'name-card';
        card.innerText = name;
        card.onclick = () => {
            heroNameEl.innerText = name;
            window.scrollTo({top: 0, behavior: 'smooth'});
        };
        nameGridEl.appendChild(card);
    });
}

// ==========================================
// 3. Neural Network Engine
// ==========================================
let seed = 42;
function random() {
    seed = (seed * 9301 + 49297) % 233280;
    return seed / 233280;
}
function gaussRandom() {
    let u = 0, v = 0;
    while(u === 0) u = random();
    while(v === 0) v = random();
    return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
}
function randn(std = 1) { return gaussRandom() * std; }

class Value {
    constructor(data, children = [], localGrads = []) {
        this.data = data;
        this.grad = 0;
        this._children = children;
        this._localGrads = localGrads;
    }
    add(other) {
        other = other instanceof Value ? other : new Value(other);
        return new Value(this.data + other.data, [this, other], [1, 1]);
    }
    mul(other) {
        other = other instanceof Value ? other : new Value(other);
        return new Value(this.data * other.data, [this, other], [other.data, this.data]);
    }
    pow(other) { return new Value(this.data ** other, [this], [other * this.data ** (other - 1)]); }
    log() { const safeData = Math.max(this.data, 1e-10); return new Value(Math.log(safeData), [this], [1 / safeData]); }
    exp() { const x = Math.min(this.data, 20); return new Value(Math.exp(x), [this], [Math.exp(x)]); }
    relu() { return new Value(Math.max(0, this.data), [this], [this.data > 0 ? 1 : 0]); }
    neg() { return this.mul(-1); }
    sub(other) { return this.add(other instanceof Value ? other.neg() : -other); }
    div(other) { return this.mul(other instanceof Value ? other.pow(-1) : new Value(other).pow(-1)); }
    backward() {
        const topo = []; const visited = new Set();
        const buildTopo = (v) => {
            if (!visited.has(v)) { visited.add(v); v._children.forEach(child => buildTopo(child)); topo.push(v); }
        };
        buildTopo(this);
        this.grad = 1;
        for (let i = topo.length - 1; i >= 0; i--) {
            const v = topo[i];
            for (let j = 0; j < v._children.length; j++) {
                v._children[j].grad += v._localGrads[j] * v.grad;
            }
        }
    }
}

function sumVals(arr) { return arr.reduce((a, b) => a.add(b), new Value(0)); }
function matrix(nout, nin, std = 0.08) {
    const m = [];
    for (let i = 0; i < nout; i++) {
        const row = [];
        for (let j = 0; j < nin; j++) row.push(new Value(randn(std)));
        m.push(row);
    }
    return m;
}
function linear(x, w) {
    const out = [];
    for (let i = 0; i < w.length; i++) {
        let sum = new Value(0);
        for (let j = 0; j < x.length; j++) sum = sum.add(w[i][j].mul(x[j]));
        out.push(sum);
    }
    return out;
}
function softmax(logits) {
    const maxVal = Math.max(...logits.map(l => l.data));
    const exps = logits.map(l => l.sub(maxVal).exp());
    const total = sumVals(exps);
    if (total.data === 0) return logits.map(l => new Value(1 / logits.length)); 
    return exps.map(e => e.div(total));
}
function rmsnorm(x) {
    const n = x.length;
    let ms = new Value(0);
    x.forEach(xi => { ms = ms.add(xi.mul(xi)); });
    ms = ms.div(n);
    return x.map(xi => xi.mul(ms.add(1e-5).pow(-0.5)));
}

// GPT function now uses passed model state or global activeModel
function gpt(token_id, pos_id, keys, values, model) {
    const m = model || activeModel; // Fallback to active if not passed
    const { state_dict, config, vocab_size, BOS } = m;
    
    const { n_layer, n_head, n_embd, block_size } = config;
    const head_dim = n_embd / n_head;
    
    if (token_id >= vocab_size) token_id = BOS;
    if (pos_id >= block_size) pos_id = block_size - 1;

    let x = state_dict['wte'][token_id].map((t, i) => t.add(state_dict['wpe'][pos_id][i]));
    x = rmsnorm(x);

    for (let li = 0; li < n_layer; li++) {
        const x_residual = x;
        x = rmsnorm(x);

        const q = linear(x, state_dict[`layer${li}.attn_wq`]);
        const k = linear(x, state_dict[`layer${li}.attn_wk`]);
        const v = linear(x, state_dict[`layer${li}.attn_wv`]);

        keys[li].push(k);
        values[li].push(v);

        const x_attn_parts = [];
        for (let h = 0; h < n_head; h++) {
            const hs = h * head_dim, he = hs + head_dim;
            const q_h = q.slice(hs, he);
            const k_h = keys[li].map(k_vec => k_vec.slice(hs, he));
            const v_h = values[li].map(v_vec => v_vec.slice(hs, he));

            const attn_logits = [];
            for (let t = 0; t < k_h.length; t++) {
                let dot = new Value(0);
                for(let j=0; j<head_dim; j++) dot = dot.add(q_h[j].mul(k_h[t][j]));
                attn_logits.push(dot.div(Math.sqrt(head_dim)));
            }
            const attn_weights = softmax(attn_logits);
            const head_out = [];
            for (let j = 0; j < head_dim; j++) {
                let sum = new Value(0);
                for (let t = 0; t < v_h.length; t++) sum = sum.add(attn_weights[t].mul(v_h[t][j]));
                head_out.push(sum);
            }
            x_attn_parts.push(...head_out);
        }

        x = linear(x_attn_parts, state_dict[`layer${li}.attn_wo`]);
        x = x.map((xi, i) => xi.add(x_residual[i]));

        const x_residual2 = x;
        x = rmsnorm(x);
        x = linear(x, state_dict[`layer${li}.mlp_fc1`]);
        x = x.map(xi => xi.relu());
        x = linear(x, state_dict[`layer${li}.mlp_fc2`]);
        x = x.map((xi, i) => xi.add(x_residual2[i]));
    }
    return linear(x, state_dict['lm_head']);
}

function importWeights(input, type) {
    try {
        const data = input;
        if (data.vocab && data.weights && data.config) {
            const modelData = {
                config: data.config,
                uchars: data.vocab,
                BOS: data.vocab.length,
                vocab_size: data.vocab.length + 1,
                state_dict: {}
            };
            
            // Reconstruct state_dict with Value objects
            for (const [key, matData] of Object.entries(data.weights)) {
                modelData.state_dict[key] = matData.map(row => row.map(val => new Value(val)));
            }

            // Save to the specific slot
            models[type].data = modelData;
            models[type].loaded = true;
            
            print(`Модель "${type}" загружена: L${modelData.config.n_layer}E${modelData.config.n_embd}. Словарь: ${modelData.vocab_size}`);
            return true;
        }
    } catch(e) {
        print("Ошибка импорта весов: " + e);
    }
    return false;
}

const MODEL_URLS = {
    names: 'https://raw.githubusercontent.com/boolkin/html/refs/heads/master/Vibe/microgpt/weights/gpt_model_L1E32.json',
    pets: 'https://raw.githubusercontent.com/boolkin/html/refs/heads/master/Vibe/microgpt/weights/gpt_model_L1E32_pets.json'
};

async function loadAIModel(type) {
    if (models[type].loaded) {
        return true; // Already loaded
    }
    if (models[type].loading) {
        return false; // Loading in progress
    }

    models[type].loading = true;
    showLoading(true);
    setStatus(`Загрузка модели "${type}"...`);
    print(`Загрузка весов для: ${type}`);
    
    try {
        const response = await fetch(MODEL_URLS[type]);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const gptWeights = await response.json();
        
        if (importWeights(gptWeights, type)) {
            setStatus("Модель готова");
            models[type].loading = false;
            showLoading(false);
            return true;
        } else {
            throw new Error("Неверный формат весов");
        }
    } catch (e) {
        setStatus("Ошибка загрузки AI");
        print("Ошибка AI: " + e.message);
        alert("Не удалось загрузить модель нейросети.");
        models[type].loading = false;
        showLoading(false);
        return false;
    }
}

async function generateFromAI() {
    const type = document.getElementById('datasetSelect').value;
    const prefix = document.getElementById('startsWith').value.trim();
    const lengthVal = document.getElementById('lengthFilter').value;
    const minLen = lengthVal ? parseInt(lengthVal) : 0;

    // 1. Ensure model is loaded and set as active
    if (!models[type].loaded) {
        const success = await loadAIModel(type);
        if (!success) return;
    }
    
    // Set active model pointer
    activeModel = models[type].data;

    showLoading(true);
    setStatus("Генерация нейросетью...");
    nameGridEl.innerHTML = "";
    
    const temperature = 0.5;
    const count = 21; 
    const maxAttempts = 200;

    function weightedChoice(items, weights) {
        const total = weights.reduce((a, b) => a + b, 0);
        const r = Math.random() * total;
        let sum = 0;
        for (let i = 0; i < items.length; i++) {
            sum += weights[i];
            if (r <= sum) return items[i];
        }
        return items[items.length - 1];
    }

    const generatedNames = [];
    let attempts = 0;

    while (generatedNames.length < count && attempts < maxAttempts) {
        attempts++;
        
        const keys = Array.from({length: activeModel.config.n_layer}, () => []);
        const values = Array.from({length: activeModel.config.n_layer}, () => []);
        const sample = [];
        
        // Start generation
        let last_logits = gpt(activeModel.BOS, 0, keys, values, activeModel);
        let current_pos = 1; 

        // --- PREFIX HANDLING ---
        if (prefix.length > 0) {
            for (let char of prefix) {
                let tid = activeModel.uchars.indexOf(char);
                if (tid === -1) continue; 
                
                sample.push(char); 
                last_logits = gpt(tid, current_pos, keys, values, activeModel); 
                current_pos++;
            }
        }
        
        // --- CONTINUE GENERATION ---
        let cont = true;
        while(cont && current_pos < activeModel.config.block_size) {
            const scaledLogits = last_logits.map(l => l.div(temperature));
            const probs = softmax(scaledLogits);
            const weights = probs.map(p => p.data);
            
            let token_id = weightedChoice([...Array(activeModel.vocab_size).keys()], weights);
            
            if (token_id === activeModel.BOS) break; 
            
            sample.push(activeModel.uchars[token_id]);
            current_pos++;
            
            last_logits = gpt(token_id, current_pos - 1, keys, values, activeModel);
        }
        
        const nameStr = sample.join('');
        
        if (nameStr.length >= minLen) {
            generatedNames.push(nameStr);
        }
        
        if (attempts % 10 === 0) await new Promise(r => setTimeout(r, 0));
    }

    if (generatedNames.length > 0) {
        const mainName = generatedNames[0];
        heroNameEl.innerText = mainName || "...";
        heroMetaEl.innerText = "Сгенерировано ИИ";
        
        nameGridEl.innerHTML = "";
        generatedNames.slice(1).forEach(name => {
            const card = document.createElement('div');
            card.className = 'name-card';
            card.innerText = name || "...";
            card.onclick = () => { heroNameEl.innerText = card.innerText; };
            nameGridEl.appendChild(card);
        });
    } else {
        heroNameEl.innerText = "Ошибка";
        heroMetaEl.innerText = `Не удалось сгенерировать имена (попыток: ${attempts})`;
    }
    
    setStatus("Готово");
    showLoading(false);
}

// ==========================================
// 4. Main Controller
// ==========================================
function generate() {
    if (currentMode === 'db') {
        generateFromDB();
    } else {
        generateFromAI();
    }
}

window.onload = async () => {
    await loadDatasets();
    generateFromDB(); 
};
</script>
</body>
</html>