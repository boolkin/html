<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPT Neural Network Lab</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1e1e1e;
            color: #ddd;
            margin: 0;
            height: 100vh;
            display: flex;
        }

        /* Sidebar Layout */
        .sidebar {
            width: 360px;
            background-color: #252526;
            padding: 20px;
            border-right: 1px solid #444;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
        }

        /* Controls Styling */
        h1 { font-size: 1.2rem; margin: 0 0 5px 0; color: #fff; }
        .subtitle { font-size: 0.8rem; color: #888; margin-bottom: 10px; }

        .section {
            background: #2d2d2d;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #3e3e42;
        }

        .section-title {
            font-size: 0.8rem;
            font-weight: bold;
            color: #4ec9b0;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            justify-content: space-between;
        }

        .control-group { margin-bottom: 10px; }
        .control-group:last-child { margin-bottom: 0; }

        .control-group label {
            display: block;
            font-size: 0.75rem;
            color: #aaa;
            margin-bottom: 3px;
        }

        .control-group input[type="number"],
        .control-group input[type="file"] {
            width: 100%;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #555;
            background: #333;
            color: #fff;
            box-sizing: border-box;
            font-size: 0.85rem;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: #333;
            border-radius: 4px;
            cursor: pointer;
        }
        .checkbox-group input { width: auto; transform: scale(1.2); }
        .checkbox-group label { margin: 0; font-size: 0.9rem; color: #fff; cursor: pointer; font-weight: bold; }

        button {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: bold;
            transition: background 0.2s;
        }

        .btn-primary { background-color: #0e639c; color: white; }
        .btn-primary:hover { background-color: #1177bb; }
        .btn-primary:disabled { background-color: #555; cursor: not-allowed; }

        .btn-secondary { background-color: #3e3e42; color: #ddd; font-size: 0.8rem; margin-top: 5px; }
        .btn-secondary:hover { background-color: #505055; }

        /* Console Styling */
        #console {
            flex: 1;
            background-color: #000;
            color: #0f0;
            padding: 15px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: 'Courier New', Courier, monospace;
            font-size: 13px;
            line-height: 1.4;
        }
        
        .status-bar {
            background: #333;
            padding: 5px 15px;
            font-size: 0.75rem;
            color: #888;
            border-top: 1px solid #444;
        }

        /* Conditional visibility class */
        .hidden { display: none; }
    </style>
</head>
<body>

<!-- Left Sidebar -->
<div class="sidebar">
    <div>
        <h1>GPT Lab</h1>
        <div class="subtitle">Конструктор и обучатель нейросети</div>
    </div>

    <!-- Mode Toggle -->
    <div class="section">
        <div class="checkbox-group" onclick="toggleTrainMode()">
            <input type="checkbox" id="chkTrain" checked onchange="toggleTrainMode()">
            <label for="chkTrain">Режим обучения</label>
        </div>
        <div class="control-group" style="margin-top:10px;">
            <label>Файл данных (names.txt)</label>
            <input type="file" id="inputFile" accept=".txt">
        </div>
    </div>

    <!-- Architecture Params (Visible only if Train Mode) -->
    <div class="section" id="sectArch">
        <div class="section-title">Архитектура модели</div>
        <div class="control-group">
            <label>Block Size (Длина контекста)</label>
            <input type="number" id="inputBlock" value="16" step="1">
        </div>
        <div class="control-group">
            <label>Размер эмбеддинга (n_embd)</label>
            <input type="number" id="inputEmbd" value="16" step="1">
        </div>
        <div class="control-group">
            <label>Количество голов внимания (n_head)</label>
            <input type="number" id="inputHeads" value="4" step="1">
        </div>
        <div class="control-group">
            <label>Количество слоев (n_layer)</label>
            <input type="number" id="inputLayers" value="1" step="1">
        </div>
    </div>

    <!-- Training Params (Visible only if Train Mode) -->
    <div class="section" id="sectTrain">
        <div class="section-title">Параметры обучения</div>
        <div class="control-group">
            <label>Seed (Случайное зерно)</label>
            <input type="number" id="inputSeed" value="42">
        </div>
        <div class="control-group">
            <label>Шаги обучения (Steps)</label>
            <input type="number" id="inputSteps" value="1000" step="100">
        </div>
        <div class="control-group">
            <label>Learning Rate (Скорость)</label>
            <input type="number" id="inputLR" value="0.01" step="0.001">
        </div>
    </div>

    <!-- Generation Params (Always Visible) -->
    <div class="section">
        <div class="section-title">Генерация</div>
        <div class="control-group">
            <label>Temperature (Креативность)</label>
            <input type="number" id="inputTemp" value="0.7" step="0.1">
        </div>
        <div class="control-group">
            <label>Кол-во имен</label>
            <input type="number" id="inputCount" value="20" step="5">
        </div>
    </div>

    <!-- Weights Management -->
    <div class="section">
        <div class="section-title">Управление весами</div>
        <button class="btn-secondary" onclick="exportWeights()">Экспорт весов (JSON)</button>
        <button class="btn-secondary" onclick="triggerImport()">Импорт весов (JSON)</button>
        <input type="file" id="importFile" accept=".json" style="display:none" onchange="importWeights(this)">
    </div>

    <button id="startBtn" class="btn-primary" onclick="startProcess()">Запуск</button>
</div>

<!-- Main Content -->
<div class="main-content">
    <div id="console"></div>
    <div class="status-bar" id="statusBar">Готов к работе</div>
</div>

<script>
// ==========================================
// 1. Core Utils & UI
// ==========================================
const consoleEl = document.getElementById('console');
const statusEl = document.getElementById('statusBar');

function print(text) {
    const div = document.createElement('div');
    div.textContent = text;
    consoleEl.appendChild(div);
    consoleEl.scrollTop = consoleEl.scrollHeight;
}

function clearConsole() { consoleEl.innerHTML = ''; }
function setStatus(text) { statusEl.textContent = text; }

// Toggle UI sections visibility
function toggleTrainMode() {
    const isTrain = document.getElementById('chkTrain').checked;
    const sectArch = document.getElementById('sectArch');
    const sectTrain = document.getElementById('sectTrain');
    
    if (isTrain) {
        sectArch.classList.remove('hidden');
        sectTrain.classList.remove('hidden');
    } else {
        sectArch.classList.add('hidden');
        sectTrain.classList.add('hidden');
    }
}
// Initialize visibility
toggleTrainMode();

// ==========================================
// 2. Random (Seeded)
// ==========================================
let seed = 42;
function random() {
    seed = (seed * 9301 + 49297) % 233280;
    return seed / 233280;
}
function gaussRandom() {
    let u = 0, v = 0;
    while(u === 0) u = random();
    while(v === 0) v = random();
    return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
}
function randn(std = 1) { return gaussRandom() * std; }
function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

// ==========================================
// 3. Autograd Engine
// ==========================================
class Value {
    constructor(data, children = [], localGrads = []) {
        this.data = data;
        this.grad = 0;
        this._children = children;
        this._localGrads = localGrads;
    }

    add(other) {
        other = other instanceof Value ? other : new Value(other);
        return new Value(this.data + other.data, [this, other], [1, 1]);
    }
    mul(other) {
        other = other instanceof Value ? other : new Value(other);
        return new Value(this.data * other.data, [this, other], [other.data, this.data]);
    }
    pow(other) { return new Value(this.data ** other, [this], [other * this.data ** (other - 1)]); }
    log() { const safeData = Math.max(this.data, 1e-10); return new Value(Math.log(safeData), [this], [1 / safeData]); }
    exp() { const x = Math.min(this.data, 20); return new Value(Math.exp(x), [this], [Math.exp(x)]); }
    relu() { return new Value(Math.max(0, this.data), [this], [this.data > 0 ? 1 : 0]); }
    neg() { return this.mul(-1); }
    sub(other) { return this.add(other instanceof Value ? other.neg() : -other); }
    div(other) { return this.mul(other instanceof Value ? other.pow(-1) : new Value(other).pow(-1)); }
    
    backward() {
        const topo = []; const visited = new Set();
        const buildTopo = (v) => {
            if (!visited.has(v)) { visited.add(v); v._children.forEach(child => buildTopo(child)); topo.push(v); }
        };
        buildTopo(this);
        this.grad = 1;
        for (let i = topo.length - 1; i >= 0; i--) {
            const v = topo[i];
            for (let j = 0; j < v._children.length; j++) {
                v._children[j].grad += v._localGrads[j] * v.grad;
            }
        }
    }
}

// ==========================================
// 4. Model Architecture
// ==========================================
function sumVals(arr) { return arr.reduce((a, b) => a.add(b), new Value(0)); }

function matrix(nout, nin, std = 0.08) {
    const m = [];
    for (let i = 0; i < nout; i++) {
        const row = [];
        for (let j = 0; j < nin; j++) row.push(new Value(randn(std)));
        m.push(row);
    }
    return m;
}

function linear(x, w) {
    const out = [];
    for (let i = 0; i < w.length; i++) {
        let sum = new Value(0);
        for (let j = 0; j < x.length; j++) sum = sum.add(w[i][j].mul(x[j]));
        out.push(sum);
    }
    return out;
}

function softmax(logits) {
    const maxVal = Math.max(...logits.map(l => l.data));
    const exps = logits.map(l => l.sub(maxVal).exp());
    const total = sumVals(exps);
    if (total.data === 0) return logits.map(l => new Value(1 / logits.length)); 
    return exps.map(e => e.div(total));
}

function rmsnorm(x) {
    const n = x.length;
    let ms = new Value(0);
    x.forEach(xi => { ms = ms.add(xi.mul(xi)); });
    ms = ms.div(n);
    return x.map(xi => xi.mul(ms.add(1e-5).pow(-0.5)));
}

// Global Model State
let state_dict = {};
let uchars = [];
let vocab_size = 0;
let BOS = 0;
let params = [];

// Configuration object
let config = {
    n_embd: 16,
    n_head: 4,
    n_layer: 1,
    block_size: 16
};

function initModel(vocab, newConfig) {
    // Update global config
    config = newConfig;
    
    uchars = vocab;
    BOS = uchars.length;
    vocab_size = uchars.length + 1;
    
    const { n_embd, n_layer, block_size } = config;
    
    state_dict = {
        'wte': matrix(vocab_size, n_embd),
        'wpe': matrix(block_size, n_embd),
        'lm_head': matrix(vocab_size, n_embd)
    };

    for (let i = 0; i < n_layer; i++) {
        state_dict[`layer${i}.attn_wq`] = matrix(n_embd, n_embd);
        state_dict[`layer${i}.attn_wk`] = matrix(n_embd, n_embd);
        state_dict[`layer${i}.attn_wv`] = matrix(n_embd, n_embd);
        state_dict[`layer${i}.attn_wo`] = matrix(n_embd, n_embd);
        state_dict[`layer${i}.mlp_fc1`] = matrix(4 * n_embd, n_embd);
        state_dict[`layer${i}.mlp_fc2`] = matrix(n_embd, 4 * n_embd);
    }

    params = [];
    Object.values(state_dict).forEach(mat => mat.forEach(row => row.forEach(val => params.push(val))));
    return params.length;
}

function gpt(token_id, pos_id, keys, values) {
    const { n_layer, n_head, n_embd, block_size } = config;
    const head_dim = n_embd / n_head;
    
    // Safety checks
    if (token_id >= vocab_size) token_id = BOS; // fallback
    if (pos_id >= block_size) pos_id = block_size - 1; // clamp position

    let x = state_dict['wte'][token_id].map((t, i) => t.add(state_dict['wpe'][pos_id][i]));
    x = rmsnorm(x);

    for (let li = 0; li < n_layer; li++) {
        const x_residual = x;
        x = rmsnorm(x);

        const q = linear(x, state_dict[`layer${li}.attn_wq`]);
        const k = linear(x, state_dict[`layer${li}.attn_wk`]);
        const v = linear(x, state_dict[`layer${li}.attn_wv`]);

        keys[li].push(k);
        values[li].push(v);

        const x_attn_parts = [];
        for (let h = 0; h < n_head; h++) {
            const hs = h * head_dim, he = hs + head_dim;
            const q_h = q.slice(hs, he);
            const k_h = keys[li].map(k_vec => k_vec.slice(hs, he));
            const v_h = values[li].map(v_vec => v_vec.slice(hs, he));

            const attn_logits = [];
            for (let t = 0; t < k_h.length; t++) {
                let dot = new Value(0);
                for(let j=0; j<head_dim; j++) dot = dot.add(q_h[j].mul(k_h[t][j]));
                attn_logits.push(dot.div(Math.sqrt(head_dim)));
            }
            const attn_weights = softmax(attn_logits);
            const head_out = [];
            for (let j = 0; j < head_dim; j++) {
                let sum = new Value(0);
                for (let t = 0; t < v_h.length; t++) sum = sum.add(attn_weights[t].mul(v_h[t][j]));
                head_out.push(sum);
            }
            x_attn_parts.push(...head_out);
        }

        x = linear(x_attn_parts, state_dict[`layer${li}.attn_wo`]);
        x = x.map((xi, i) => xi.add(x_residual[i]));

        const x_residual2 = x;
        x = rmsnorm(x);
        x = linear(x, state_dict[`layer${li}.mlp_fc1`]);
        x = x.map(xi => xi.relu());
        x = linear(x, state_dict[`layer${li}.mlp_fc2`]);
        x = x.map((xi, i) => xi.add(x_residual2[i]));
    }
    return linear(x, state_dict['lm_head']);
}

// ==========================================
// 5. Serialization
// ==========================================

function getModelData() {
    const weights = {};
    for (const [key, mat] of Object.entries(state_dict)) {
        weights[key] = mat.map(row => row.map(v => v.data));
    }
    return {
        config: config,
        vocab: uchars,
        weights: weights
    };
}

function saveToLocalStorage() {
    try {
        const data = getModelData();
        localStorage.setItem('gpt_model', JSON.stringify(data));
        print("Веса и конфигурация сохранены в LocalStorage.");
    } catch(e) {
        print("Ошибка сохранения в LocalStorage: " + e.message);
    }
}

function loadFromLocalStorage() {
    const json = localStorage.getItem('gpt_model');
    if (!json) return false;
    try {
        const data = JSON.parse(json);
        if (data.vocab && data.weights && data.config) {
            // Restore config
            config = data.config;
            
            // Restore UI from loaded config
            document.getElementById('inputBlock').value = config.block_size;
            document.getElementById('inputEmbd').value = config.n_embd;
            document.getElementById('inputHeads').value = config.n_head;
            document.getElementById('inputLayers').value = config.n_layer;

            // Restore vocab
            uchars = data.vocab;
            BOS = uchars.length;
            vocab_size = uchars.length + 1;
            
            // Restore weights
            state_dict = {};
            for (const [key, matData] of Object.entries(data.weights)) {
                state_dict[key] = matData.map(row => row.map(val => new Value(val)));
            }
            
            // Update params list
            params = [];
            Object.values(state_dict).forEach(mat => mat.forEach(row => row.forEach(val => params.push(val))));
            
            return true;
        }
    } catch(e) {
        print("Ошибка загрузки из LocalStorage: " + e.message);
    }
    return false;
}

function exportWeights() {
    if(Object.keys(state_dict).length === 0) {
        alert("Модель не инициализирована. Сначала запустите обучение.");
        return;
    }
    const data = getModelData();
    const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `gpt_model_L${config.n_layer}E${config.n_embd}.json`;
    a.click();
    URL.revokeObjectURL(url);
    print("Веса экспортированы в файл.");
}

function triggerImport() { document.getElementById('importFile').click(); }

function importWeights(input) {
    if (input.files.length === 0) return;
    const file = input.files[0];
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = JSON.parse(e.target.result);
            if (data.vocab && data.weights && data.config) {
                // Restore everything
                config = data.config;
                uchars = data.vocab;
                BOS = uchars.length;
                vocab_size = uchars.length + 1;
                
                state_dict = {};
                for (const [key, matData] of Object.entries(data.weights)) {
                    state_dict[key] = matData.map(row => row.map(val => new Value(val)));
                }
                
                params = [];
                Object.values(state_dict).forEach(mat => mat.forEach(row => row.forEach(val => params.push(val))));
                
                // Update UI
                document.getElementById('inputBlock').value = config.block_size;
                document.getElementById('inputEmbd').value = config.n_embd;
                document.getElementById('inputHeads').value = config.n_head;
                document.getElementById('inputLayers').value = config.n_layer;
                
                localStorage.setItem('gpt_model', JSON.stringify(data));
                
                print(`Импортирована модель: ${config.n_layer} слоев, ${config.n_embd} эмбеддинг.`);
                alert("Веса успешно загружены! Теперь можете запустить генерацию (уберите галочку 'Обучать').");
            } else {
                alert("Неверный формат файла.");
            }
        } catch(e) {
            alert("Ошибка чтения JSON: " + e);
        }
    };
    reader.readAsText(file);
    input.value = '';
}

// ==========================================
// 6. Main Logic
// ==========================================
async function startProcess() {
    const btn = document.getElementById('startBtn');
    btn.disabled = true;
    clearConsole();
    
    const isTrain = document.getElementById('chkTrain').checked;
    
    // If Generation Only Mode
    if (!isTrain) {
        print("Режим: Генерация без обучения.");
        setStatus("Загрузка весов...");
        
        if (Object.keys(state_dict).length === 0) {
            if (!loadFromLocalStorage()) {
                print("Ошибка: Веса не найдены. Включите обучение или импортируйте веса.");
                btn.disabled = false;
                return;
            }
        }
        
        print(`Модель загружена. Архитектура: Layers=${config.n_layer}, Embd=${config.n_embd}, Heads=${config.n_head}.`);
        await generateNames();
        btn.disabled = false;
        return;
    }

    // --- Training Mode ---
    print("Режим: Обучение.");
    
    // Read Configuration from UI
    const newConfig = {
        block_size: parseInt(document.getElementById('inputBlock').value),
        n_embd: parseInt(document.getElementById('inputEmbd').value),
        n_head: parseInt(document.getElementById('inputHeads').value),
        n_layer: parseInt(document.getElementById('inputLayers').value)
    };

    // Basic Validation
    if (newConfig.n_embd % newConfig.n_head !== 0) {
        alert("Ошибка: Размер эмбеддинга должен делиться на количество голов без остатка!");
        btn.disabled = false;
        return;
    }

    seed = parseInt(document.getElementById('inputSeed').value);
    const num_steps = parseInt(document.getElementById('inputSteps').value);
    const learning_rate = parseFloat(document.getElementById('inputLR').value);
    
    let docs = [];
    setStatus("Загрузка данных...");
    
    const fileInput = document.getElementById('inputFile');
    if (fileInput.files.length > 0) {
        const text = await fileInput.files[0].text();
        docs = text.trim().split('\n').map(l => l.trim()).filter(l => l);
    } else {
        try {
            const resp = await fetch('https://raw.githubusercontent.com/karpathy/makemore/refs/heads/master/names.txt');
            docs = (await resp.text()).trim().split('\n').map(l => l.trim()).filter(l => l);
        } catch(e) {
            docs = ["emma", "olivia", "ava", "sophia", "isabella", "mia"];
        }
    }
    
    shuffle(docs);
    print(`Данные: ${docs.length} примеров.`);

    const vocab = Array.from(new Set(docs.join(''))).sort();
    const num_params = initModel(vocab, newConfig);
    print(`Параметры модели: Layers=${config.n_layer}, Embd=${config.n_embd}, Heads=${config.n_head}`);
    print(`Всего параметров: ${num_params}. Начинаем обучение...`);

    const beta1 = 0.85, beta2 = 0.99, eps_adam = 1e-8;
    const m = new Array(params.length).fill(0);
    const v = new Array(params.length).fill(0);

    for (let step = 0; step < num_steps; step++) {
        const doc = docs[step % docs.length];
        const tokens = [BOS, ...doc.split('').map(ch => uchars.indexOf(ch)), BOS];
        const n = Math.min(config.block_size, tokens.length - 1);

        const keys = Array.from({length: config.n_layer}, () => []);
        const values = Array.from({length: config.n_layer}, () => []);
        const losses = [];

        for (let pos_id = 0; pos_id < n; pos_id++) {
            const token_id = tokens[pos_id], target_id = tokens[pos_id + 1];
            const logits = gpt(token_id, pos_id, keys, values);
            const probs = softmax(logits);
            losses.push(probs[target_id].log().mul(-1));
        }

        const loss = sumVals(losses).div(n);
        loss.backward();

        const lr_t = learning_rate * (1 - step / num_steps);
        
        for (let i = 0; i < params.length; i++) {
            const p = params[i], grad = p.grad;
            m[i] = beta1 * m[i] + (1 - beta1) * grad;
            v[i] = beta2 * v[i] + (1 - beta2) * (grad ** 2);
            const m_hat = m[i] / (1 - beta1 ** (step + 1));
            const v_hat = v[i] / (1 - beta2 ** (step + 1));
            p.data -= lr_t * m_hat / (Math.sqrt(v_hat) + eps_adam);
            p.grad = 0;
        }

        if ((step + 1) % 50 === 0) {
            print(`step ${step+1} / ${num_steps} | loss ${loss.data.toFixed(4)}`);
            setStatus(`Обучение... ${step+1}/${num_steps}`);
            await new Promise(r => setTimeout(r, 0)); 
        }
    }

    print("Обучение завершено.");
    saveToLocalStorage();
    
    await generateNames();
    btn.disabled = false;
}

async function generateNames() {
    const temperature = parseFloat(document.getElementById('inputTemp').value);
    const count = parseInt(document.getElementById('inputCount').value);
    
    print(`\n--- Генерация (${count} имен, T=${temperature}) ---`);

    function weightedChoice(items, weights) {
        const total = weights.reduce((a, b) => a + b, 0);
        const r = Math.random() * total;
        let sum = 0;
        for (let i = 0; i < items.length; i++) {
            sum += weights[i];
            if (r <= sum) return items[i];
        }
        return items[items.length - 1];
    }

    for (let s = 0; s < count; s++) {
        const keys = Array.from({length: config.n_layer}, () => []);
        const values = Array.from({length: config.n_layer}, () => []);
        let token_id = BOS;
        const sample = [];
        
        for (let pos_id = 0; pos_id < config.block_size; pos_id++) {
            const logits = gpt(token_id, pos_id, keys, values);
            const scaledLogits = logits.map(l => l.div(temperature));
            const probs = softmax(scaledLogits);
            const weights = probs.map(p => p.data);
            
            token_id = weightedChoice([...Array(vocab_size).keys()], weights);
            
            if (token_id === BOS) break;
            sample.push(uchars[token_id]);
        }
        print(`${s+1}. ${sample.join('')}`);
        if(s % 5 === 0) await new Promise(r => setTimeout(r, 0));
    }
}
</script>
</body>
</html>