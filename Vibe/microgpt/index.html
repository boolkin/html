<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GPT Neural Network Lab</title>
    <script src="chart.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>

<body>

    <!-- Overlay (dimmed background) -->
    <div class="sidebar-overlay" id="overlay" onclick="toggleSidebar()"></div>

    <!-- Left Sidebar -->
    <div class="sidebar" id="sidebar">
        <!-- Header Block (Visible only on Desktop) -->
        <div class="full-width header-block">
            <h1>MicroGPT on JS</h1>
            <div class="subtitle"><big>–ü–æ–ø—Ä–æ–±—É–π –æ–±—É—á–∏—Ç—å —Å–≤–æ—é –Ω–µ–π—Ä–æ—Å–µ—Ç—å</big><br>C–¥–µ–ª–∞–Ω–æ –Ω–∞ –æ—Å–Ω–æ–≤–µ <a
                    href="https://habr.com/ru/articles/996404/" target="_blank">microgpt</a></div>
        </div>

        <!-- Mode Toggle -->
        <div class="section full-width" style="padding:0; border:none; background: transparent;"
            onclick="toggleTrainMode()">
            <div class="checkbox-group">
                <input type="checkbox" id="chkTrain" onchange="updateButtonLabels()">
                <label for="chkTrain">–†–µ–∂–∏–º –æ–±—É—á–µ–Ω–∏—è</label>
            </div>
        </div>

        <!-- Architecture Params -->
        <div class="section" id="sectArch">
            <div class="section-title">–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞</div>
            <div class="control-group">
                <label>Block Size</label>
                <input type="number" id="inputBlock" value="16" step="1">
            </div>
            <div class="control-group">
                <label>n_embd</label>
                <input type="number" id="inputEmbd" value="16" step="1">
            </div>
            <div class="control-group">
                <label>n_head</label>
                <input type="number" id="inputHeads" value="4" step="1">
            </div>
            <div class="control-group">
                <label>n_layer</label>
                <input type="number" id="inputLayers" value="1" step="1">
            </div>
        </div>

        <!-- Training Params -->
        <div class="section" id="sectTrain">
            <div class="section-title">–û–±—É—á–µ–Ω–∏–µ</div>
            <div class="control-group">
                <label>Seed</label>
                <input type="number" id="inputSeed" value="42">
            </div>
            <div class="control-group">
                <label>Steps</label>
                <input type="number" id="inputSteps" value="1000" step="100">
            </div>
            <div class="control-group">
                <label>Learning Rate</label>
                <input type="number" id="inputLR" value="0.01" step="0.001">
            </div>
            <div class="control-group" style="margin-top:5px;">
                <label>–§–∞–π–ª –¥–∞–Ω–Ω—ã—Ö</label>
                <input type="file" id="inputFile" accept=".txt">
            </div>
        </div>

        <!-- Generation Params -->
        <div class="section">
            <div class="section-title">–ì–µ–Ω–µ—Ä–∞—Ü–∏—è</div>
            <div class="control-group">
                <label>Temperature</label>
                <input type="number" id="inputTemp" value="0.5" step="0.1">
            </div>
            <div class="control-group">
                <label>–ö–æ–ª-–≤–æ –∏–º–µ–Ω</label>
                <input type="number" id="inputCount" value="20" step="5">
            </div>
            <div class="control-group">
                <label>–ü—Ä–µ—Ñ–∏–∫—Å (–Ω–∞—á–∞–ª–æ –∏–º–µ–Ω–∏)</label>
                <input type="text" id="inputPrefix" value="" placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä: –ë–æ—Ä, –ê–ª" maxlength="16">
                <small style="color:var(--text-dim); font-size:0.7rem;">–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –±—É–¥—É—Ç –ø—Ä–æ–ø—É—â–µ–Ω—ã, —É—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è
                    —Ä–µ–≥–∏—Å—Ç—Ä</small>
            </div>
        </div>

        <!-- Weights Management -->
        <div class="section">
            <div class="section-title">–ü—Ä–æ—á–µ–µ</div>
            <div class="btn-group">
                <button class="btn-secondary" onclick="openChartModal()">–ü–æ–∫–∞–∑–∞—Ç—å –≥—Ä–∞—Ñ–∏–∫ –æ–±—É—á–µ–Ω–∏—è</button>
            </div>
            <div class="control-group">
                <label>–í—ã–≤–æ–¥ –≤ –∫–æ–Ω—Å–æ–ª—å</label>
                <input type="number" id="ConsoleCount" value="10" step="5">
                <small style="color:var(--text-dim); font-size:0.7rem;">–í—ã–≤–æ–¥–∏—Ç—å –≤ –∫–æ–Ω—Å–æ–ª—å –∫–∞–∂–¥—ã–π n —à–∞–≥ –ø—Ä–∏
                    –æ–±—É—á–µ–Ω–∏–∏</small>
            </div>
            <div class="btn-group">
                <button class="btn-secondary" onclick="exportWeights()">–≠–∫—Å–ø–æ—Ä—Ç (JSON)</button>
                <button class="btn-secondary" onclick="triggerImport()">–ò–º–ø–æ—Ä—Ç (JSON)</button>
                <input type="file" id="importFile" accept=".json" style="display:none" onchange="importWeights(this)">
            </div>
        </div>

        <!-- Start Button (Visible only on Desktop via CSS) -->
        <button id="startBtn" class="btn-primary full-width" onclick="startProcess()">–ó–∞–ø—É—Å–∫</button>
    </div>

    <!-- Main Content Area -->
    <div class="main-content">

        <!-- Mobile Top Bar -->
        <div class="mobile-header">
            <div class="mobile-header-content">
                <div>
                    <h1>MicroGPT on JS</h1>
                    <div class="subtitle">–ü–æ–ø—Ä–æ–±—É–π –æ–±—É—á–∏—Ç—å —Å–≤–æ—é –Ω–µ–π—Ä–æ—Å–µ—Ç—å (—Å–¥–µ–ª–∞–Ω–æ –∏–∑ <a
                            href="https://habr.com/ru/articles/996404/" target="_blank">microgpt)</a></div>
                </div>
            </div>
            <div class="mobile-header-buttons">
                <button class="btn-secondary" onclick="toggleSidebar()">‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏</button>
                <button id="mobileStartBtn" class="btn-primary" onclick="startProcess()">‚ñ∂ –ó–∞–ø—É—Å–∫</button>
            </div>
        </div>

        <div id="console"></div>
        <div class="status-bar" id="statusBar">–ì–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ</div>
    </div>

    <!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ -->
    <div id="chartModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üìâ –ì—Ä–∞—Ñ–∏–∫ –æ–±—É—á–µ–Ω–∏—è (Step vs Loss)</h3>
                <span class="close-btn" onclick="closeChartModal()">&times;</span>
            </div>
            <div class="chart-container">
                <canvas id="lossChart"></canvas>
            </div>
            <!-- –ö–Ω–æ–ø–∫–∏ –¥–µ–π—Å—Ç–≤–∏–π -->
            <div class="modal-actions">
                <button class="btn-save" onclick="saveChartAsImage()">
                    üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≥—Ä–∞—Ñ–∏–∫ (PNG)
                </button>
            </div>

        </div>
    </div>

    <script>
        let myChart = null;
        function openChartModal() {
            const modal = document.getElementById('chartModal');
            modal.style.display = "block";
            document.body.style.overflow = "hidden";
            drawChart();
        }

        function closeChartModal() {
            const modal = document.getElementById('chartModal');
            modal.style.display = "none";
            document.body.style.overflow = "auto";
        }

        window.onclick = function (event) {
            const modal = document.getElementById('chartModal');
            if (event.target == modal) {
                closeChartModal();
            }
        }
        // ============================================
        // –§–£–ù–ö–¶–ò–Ø –°–û–•–†–ê–ù–ï–ù–ò–Ø –ì–†–ê–§–ò–ö–ê –ö–ê–ö –ö–ê–†–¢–ò–ù–ö–ò
        // ============================================
        function saveChartAsImage() {
            if (!myChart) {
                alert('–°–Ω–∞—á–∞–ª–∞ –æ—Ç–∫—Ä–æ–π—Ç–µ –≥—Ä–∞—Ñ–∏–∫!');
                return;
            }

            const originalCanvas = document.getElementById('lossChart');

            // –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π canvas –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å —Ñ–æ–Ω–æ–º
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');

            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–æ—Ç –∂–µ —Ä–∞–∑–º–µ—Ä
            tempCanvas.width = originalCanvas.width;
            tempCanvas.height = originalCanvas.height;

            // –†–∏—Å—É–µ–º —Ç–µ–º–Ω—ã–π —Ñ–æ–Ω
            tempCtx.fillStyle = '#1e1e2f';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            // –†–∏—Å—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π canvas –ø–æ–≤–µ—Ä—Ö —Ñ–æ–Ω–∞
            tempCtx.drawImage(originalCanvas, 0, 0);

            // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ PNG
            const imageBase64 = tempCanvas.toDataURL('image/png', 1.0);

            // –°–∫–∞—á–∏–≤–∞–µ–º
            const link = document.createElement('a');
            link.download = `loss_graph_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.png`;
            link.href = imageBase64;

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function drawChart() {
            const consoleText = document.getElementById('console').innerText;
            const lines = consoleText.split('\n');

            const steps = [];
            const losses = [];

            // –†–µ–≥—É–ª—è—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞
            const regex = /step\s+(\d+)\s*\/\s*\d+\s*\|\s*loss\s+([\d.]+)/i;

            lines.forEach(line => {
                const match = line.match(regex);
                if (match) {
                    const step = parseInt(match[1]);
                    const loss = parseFloat(match[2]);
                    if (!isNaN(step) && !isNaN(loss)) {
                        steps.push(step);
                        losses.push(loss);
                    }
                }
            });

            if (steps.length === 0) {
                alert('–ù–µ –Ω–∞–π–¥–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫–∞!');
                return;
            }

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω –¥–∞–Ω–Ω—ã—Ö
            const minStep = Math.min(...steps);
            const maxStep = Math.max(...steps);
            const minLoss = Math.min(...losses);
            const maxLoss = Math.max(...losses);

            // –í—ã—á–∏—Å–ª—è–µ–º —à–∞–≥ –¥–ª—è –æ—Å–∏ X –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏
            const range = maxStep - minStep;
            let xStepSize = 1;
            if (range > 500) {
                xStepSize = 50;
            } else if (range > 100) {
                xStepSize = 10;
            } else if (range > 50) {
                xStepSize = 5;
            } else if (range > 20) {
                xStepSize = 2;
            }

            // –°–æ–∑–¥–∞–µ–º –º–∞—Å—Å–∏–≤ –¥–∞–Ω–Ω—ã—Ö
            const chartData = steps.map((step, index) => ({
                x: step,
                y: losses[index]
            }));

            const ctx = document.getElementById('lossChart').getContext('2d');

            if (myChart) {
                myChart.destroy();
            }

            const canvas = document.getElementById('lossChart');
            canvas.width = 1000;   // –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —à–∏—Ä–∏–Ω–∞ (–º–∏–Ω—É—Å padding 30px*2)
            canvas.height = 496;  // –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤—ã—Å–æ—Ç–∞

            myChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Loss',
                        data: chartData,

                        // –¢–û–õ–¨–ö–û –¢–û–ß–ö–ò, –ë–ï–ó –õ–ò–ù–ò–ô
                        showLine: false,
                        pointRadius: 8,
                        pointHoverRadius: 8,  // –ù–µ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏
                        pointBackgroundColor: 'rgba(0, 217, 255, 0.9)',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2,
                        pointStyle: 'circle',

                        borderColor: '#00d9ff',
                        backgroundColor: 'rgba(0, 217, 255, 0.6)',
                        borderWidth: 0,
                        fill: false
                    }]
                },
                options: {
                    responsive: false,
                    maintainAspectRatio: false,
                    devicePixelRatio: false,
                    // –û–¢–ö–õ–Æ–ß–ê–ï–ú –í–°–ï –ò–ù–¢–ï–†–ê–ö–¢–ò–í–ù–´–ï –≠–õ–ï–ú–ï–ù–¢–´
                    hover: {
                        mode: null,
                        intersect: true
                    },

                    plugins: {
                        // –û–¢–ö–õ–Æ–ß–ê–ï–ú –í–°–ü–õ–´–í–ê–Æ–©–ò–ï –ü–û–î–°–ö–ê–ó–ö–ò
                        tooltip: {
                            enabled: false
                        },

                        // –û–¢–ö–õ–Æ–ß–ê–ï–ú –õ–ï–ì–ï–ù–î–£ (–µ—Å–ª–∏ –Ω–µ –Ω—É–∂–Ω–∞)
                        legend: {
                            display: false
                        }
                    },

                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            min: minStep - 1,
                            max: maxStep + 1,
                            title: {
                                display: true,
                                text: '–®–∞–≥ –æ–±—É—á–µ–Ω–∏—è (Step)',
                                color: '#00d9ff',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)',
                                drawBorder: true,
                                borderColor: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#aaa',
                                stepSize: xStepSize,
                                font: {
                                    size: 11
                                },
                                callback: function (value) {
                                    return Math.round(value);
                                }
                            }
                        },
                        y: {
                            min: Math.max(0, minLoss - 0.5),
                            max: maxLoss + 0.5,
                            title: {
                                display: true,
                                text: '–§—É–Ω–∫—Ü–∏—è –ø–æ—Ç–µ—Ä—å (Loss)',
                                color: '#00d9ff',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)',
                                drawBorder: true,
                                borderColor: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#aaa',
                                font: {
                                    size: 11
                                },
                                callback: function (value) {
                                    return value.toFixed(2);
                                }
                            }
                        }
                    }
                }
            });
        }


        // ==========================================
        // 1. Core Utils & UI
        // ==========================================
        const consoleEl = document.getElementById('console');
        const statusEl = document.getElementById('statusBar');
        const sidebar = document.getElementById('sidebar');
        const overlay = document.getElementById('overlay');
        const chkTrain = document.getElementById('chkTrain');
        const startBtnDesktop = document.getElementById('startBtn');
        const startBtnMobile = document.getElementById('mobileStartBtn');

        function print(text) {
            const div = document.createElement('div');
            div.textContent = text;
            consoleEl.appendChild(div);
            window.scrollTo(0, document.body.scrollHeight);
        }

        function clearConsole() { consoleEl.innerHTML = ''; }
        function setStatus(text) { statusEl.textContent = text; }

        // Toggle Sidebar (Mobile)
        function toggleSidebar() {
            sidebar.classList.toggle('open');
            overlay.classList.toggle('visible');
        }

        // Update Button Labels based on Mode
        function updateButtonLabels() {
            const isTrain = chkTrain.checked;
            const text = isTrain ? "üöÄ –ó–∞–ø—É—Å–∫ –æ–±—É—á–µ–Ω–∏—è" : "‚ú® –ó–∞–ø—É—Å–∫ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏";

            startBtnDesktop.textContent = text;
            startBtnMobile.textContent = text;
        }

        // Toggle UI sections visibility
        function toggleTrainMode() {
            // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º —á–µ–∫–±–æ–∫—Å (–Ω–∞ —Å–ª—É—á–∞–π –≤—ã–∑–æ–≤–∞ –∏–∑ label)
            // chkTrain.checked —É–∂–µ –æ–±–Ω–æ–≤–ª–µ–Ω –±—Ä–∞—É–∑–µ—Ä–æ–º –¥–æ –≤—ã–∑–æ–≤–∞ onchange, 
            // –Ω–æ –µ—Å–ª–∏ –≤—ã–∑—ã–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é –≤—Ä—É—á–Ω—É—é, –Ω—É–∂–Ω–æ –±—ã—Ç—å –∞–∫–∫—É—Ä–∞—Ç–Ω—ã–º.

            const isTrain = chkTrain.checked;
            const sectArch = document.getElementById('sectArch');
            const sectTrain = document.getElementById('sectTrain');

            if (isTrain) {
                sectArch.classList.remove('hidden');
                sectTrain.classList.remove('hidden');
            } else {
                sectArch.classList.add('hidden');
                sectTrain.classList.add('hidden');
            }

            updateButtonLabels();
        }

        // Initialize UI state
        toggleTrainMode();

        // ==========================================
        // 2. Random (Seeded)
        // ==========================================
        let seed = 42;
        function random() {
            seed = (seed * 9301 + 49297) % 233280;
            return seed / 233280;
        }
        function gaussRandom() {
            let u = 0, v = 0;
            while (u === 0) u = random();
            while (v === 0) v = random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }
        function randn(std = 1) { return gaussRandom() * std; }
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // ==========================================
        // 3. Autograd Engine
        // ==========================================
        class Value {
            constructor(data, children = [], localGrads = []) {
                this.data = data;
                this.grad = 0;
                this._children = children;
                this._localGrads = localGrads;
            }

            add(other) {
                other = other instanceof Value ? other : new Value(other);
                return new Value(this.data + other.data, [this, other], [1, 1]);
            }
            mul(other) {
                other = other instanceof Value ? other : new Value(other);
                return new Value(this.data * other.data, [this, other], [other.data, this.data]);
            }
            pow(other) { return new Value(this.data ** other, [this], [other * this.data ** (other - 1)]); }
            log() { const safeData = Math.max(this.data, 1e-10); return new Value(Math.log(safeData), [this], [1 / safeData]); }
            exp() { const x = Math.min(this.data, 20); return new Value(Math.exp(x), [this], [Math.exp(x)]); }
            relu() { return new Value(Math.max(0, this.data), [this], [this.data > 0 ? 1 : 0]); }
            neg() { return this.mul(-1); }
            sub(other) { return this.add(other instanceof Value ? other.neg() : -other); }
            div(other) { return this.mul(other instanceof Value ? other.pow(-1) : new Value(other).pow(-1)); }

            backward() {
                const topo = []; const visited = new Set();
                const buildTopo = (v) => {
                    if (!visited.has(v)) { visited.add(v); v._children.forEach(child => buildTopo(child)); topo.push(v); }
                };
                buildTopo(this);
                this.grad = 1;
                for (let i = topo.length - 1; i >= 0; i--) {
                    const v = topo[i];
                    for (let j = 0; j < v._children.length; j++) {
                        v._children[j].grad += v._localGrads[j] * v.grad;
                    }
                }
            }
        }

        // ==========================================
        // 4. Model Architecture
        // ==========================================
        function sumVals(arr) { return arr.reduce((a, b) => a.add(b), new Value(0)); }

        function matrix(nout, nin, std = 0.08) {
            const m = [];
            for (let i = 0; i < nout; i++) {
                const row = [];
                for (let j = 0; j < nin; j++) row.push(new Value(randn(std)));
                m.push(row);
            }
            return m;
        }

        function linear(x, w) {
            const out = [];
            for (let i = 0; i < w.length; i++) {
                let sum = new Value(0);
                for (let j = 0; j < x.length; j++) sum = sum.add(w[i][j].mul(x[j]));
                out.push(sum);
            }
            return out;
        }

        function softmax(logits) {
            const maxVal = Math.max(...logits.map(l => l.data));
            const exps = logits.map(l => l.sub(maxVal).exp());
            const total = sumVals(exps);
            if (total.data === 0) return logits.map(l => new Value(1 / logits.length));
            return exps.map(e => e.div(total));
        }

        function rmsnorm(x) {
            const n = x.length;
            let ms = new Value(0);
            x.forEach(xi => { ms = ms.add(xi.mul(xi)); });
            ms = ms.div(n);
            return x.map(xi => xi.mul(ms.add(1e-5).pow(-0.5)));
        }

        // Global Model State
        let state_dict = {};
        let uchars = [];
        let vocab_size = 0;
        let BOS = 0;
        let params = [];

        // Configuration object
        let config = {
            n_embd: 16,
            n_head: 4,
            n_layer: 1,
            block_size: 16
        };

        function initModel(vocab, newConfig) {
            config = newConfig;

            uchars = vocab;
            BOS = uchars.length;
            vocab_size = uchars.length + 1;

            const { n_embd, n_layer, block_size } = config;

            state_dict = {
                'wte': matrix(vocab_size, n_embd),
                'wpe': matrix(block_size, n_embd),
                'lm_head': matrix(vocab_size, n_embd)
            };

            for (let i = 0; i < n_layer; i++) {
                state_dict[`layer${i}.attn_wq`] = matrix(n_embd, n_embd);
                state_dict[`layer${i}.attn_wk`] = matrix(n_embd, n_embd);
                state_dict[`layer${i}.attn_wv`] = matrix(n_embd, n_embd);
                state_dict[`layer${i}.attn_wo`] = matrix(n_embd, n_embd);
                state_dict[`layer${i}.mlp_fc1`] = matrix(4 * n_embd, n_embd);
                state_dict[`layer${i}.mlp_fc2`] = matrix(n_embd, 4 * n_embd);
            }

            params = [];
            Object.values(state_dict).forEach(mat => mat.forEach(row => row.forEach(val => params.push(val))));
            return params.length;
        }

        function gpt(token_id, pos_id, keys, values) {
            const { n_layer, n_head, n_embd, block_size } = config;
            const head_dim = n_embd / n_head;

            if (token_id >= vocab_size) token_id = BOS;
            if (pos_id >= block_size) pos_id = block_size - 1;

            let x = state_dict['wte'][token_id].map((t, i) => t.add(state_dict['wpe'][pos_id][i]));
            x = rmsnorm(x);

            for (let li = 0; li < n_layer; li++) {
                const x_residual = x;
                x = rmsnorm(x);

                const q = linear(x, state_dict[`layer${li}.attn_wq`]);
                const k = linear(x, state_dict[`layer${li}.attn_wk`]);
                const v = linear(x, state_dict[`layer${li}.attn_wv`]);

                keys[li].push(k);
                values[li].push(v);

                const x_attn_parts = [];
                for (let h = 0; h < n_head; h++) {
                    const hs = h * head_dim, he = hs + head_dim;
                    const q_h = q.slice(hs, he);
                    const k_h = keys[li].map(k_vec => k_vec.slice(hs, he));
                    const v_h = values[li].map(v_vec => v_vec.slice(hs, he));

                    const attn_logits = [];
                    for (let t = 0; t < k_h.length; t++) {
                        let dot = new Value(0);
                        for (let j = 0; j < head_dim; j++) dot = dot.add(q_h[j].mul(k_h[t][j]));
                        attn_logits.push(dot.div(Math.sqrt(head_dim)));
                    }
                    const attn_weights = softmax(attn_logits);
                    const head_out = [];
                    for (let j = 0; j < head_dim; j++) {
                        let sum = new Value(0);
                        for (let t = 0; t < v_h.length; t++) sum = sum.add(attn_weights[t].mul(v_h[t][j]));
                        head_out.push(sum);
                    }
                    x_attn_parts.push(...head_out);
                }

                x = linear(x_attn_parts, state_dict[`layer${li}.attn_wo`]);
                x = x.map((xi, i) => xi.add(x_residual[i]));

                const x_residual2 = x;
                x = rmsnorm(x);
                x = linear(x, state_dict[`layer${li}.mlp_fc1`]);
                x = x.map(xi => xi.relu());
                x = linear(x, state_dict[`layer${li}.mlp_fc2`]);
                x = x.map((xi, i) => xi.add(x_residual2[i]));
            }
            return linear(x, state_dict['lm_head']);
        }

        // ==========================================
        // 5. Serialization
        // ==========================================

        function getModelData() {
            const weights = {};
            for (const [key, mat] of Object.entries(state_dict)) {
                weights[key] = mat.map(row => row.map(v => v.data));
            }
            return {
                config: config,
                vocab: uchars,
                weights: weights
            };
        }

        function saveToLocalStorage() {
            try {
                const data = getModelData();
                localStorage.setItem('gpt_model', JSON.stringify(data));
                print("–í–µ—Å–∞ –∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ LocalStorage.");
            } catch (e) {
                print("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ LocalStorage: " + e.message);
            }
        }

        function loadFromLocalStorage() {
            const json = localStorage.getItem('gpt_model');
            if (!json) return false;
            try {
                const data = JSON.parse(json);
                if (data.vocab && data.weights && data.config) {
                    config = data.config;

                    document.getElementById('inputBlock').value = config.block_size;
                    document.getElementById('inputEmbd').value = config.n_embd;
                    document.getElementById('inputHeads').value = config.n_head;
                    document.getElementById('inputLayers').value = config.n_layer;

                    uchars = data.vocab;
                    BOS = uchars.length;
                    vocab_size = uchars.length + 1;

                    state_dict = {};
                    for (const [key, matData] of Object.entries(data.weights)) {
                        state_dict[key] = matData.map(row => row.map(val => new Value(val)));
                    }

                    params = [];
                    Object.values(state_dict).forEach(mat => mat.forEach(row => row.forEach(val => params.push(val))));

                    return true;
                }
            } catch (e) {
                print("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑ LocalStorage: " + e.message);
            }
            return false;
        }

        function exportWeights() {
            if (Object.keys(state_dict).length === 0) {
                alert("–ú–æ–¥–µ–ª—å –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞. –°–Ω–∞—á–∞–ª–∞ –∑–∞–ø—É—Å—Ç–∏—Ç–µ –æ–±—É—á–µ–Ω–∏–µ.");
                return;
            }
            const data = getModelData();
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `gpt_model_L${config.n_layer}E${config.n_embd}.json`;
            a.click();
            URL.revokeObjectURL(url);
            print("–í–µ—Å–∞ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã –≤ —Ñ–∞–π–ª.");
        }

        function triggerImport() { document.getElementById('importFile').click(); }

        function importWeights(input) {
            if (input.files.length === 0) return;
            const file = input.files[0];
            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.vocab && data.weights && data.config) {
                        config = data.config;
                        uchars = data.vocab;
                        BOS = uchars.length;
                        vocab_size = uchars.length + 1;

                        state_dict = {};
                        for (const [key, matData] of Object.entries(data.weights)) {
                            state_dict[key] = matData.map(row => row.map(val => new Value(val)));
                        }

                        params = [];
                        Object.values(state_dict).forEach(mat => mat.forEach(row => row.forEach(val => params.push(val))));

                        document.getElementById('inputBlock').value = config.block_size;
                        document.getElementById('inputEmbd').value = config.n_embd;
                        document.getElementById('inputHeads').value = config.n_head;
                        document.getElementById('inputLayers').value = config.n_layer;

                        localStorage.setItem('gpt_model', JSON.stringify(data));

                        print(`–ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞ –º–æ–¥–µ–ª—å: ${config.n_layer} —Å–ª–æ–µ–≤, ${config.n_embd} —ç–º–±–µ–¥–¥–∏–Ω–≥.`);
                        alert("–í–µ—Å–∞ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã! –¢–µ–ø–µ—Ä—å –º–æ–∂–µ—Ç–µ –∑–∞–ø—É—Å—Ç–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é.");

                        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –≤ —Ä–µ–∂–∏–º –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
                        chkTrain.checked = false;
                        toggleTrainMode();
                        toggleSidebar(); // –ó–∞–∫—Ä—ã–≤–∞–µ–º –º–µ–Ω—é –ø–æ—Å–ª–µ –∏–º–ø–æ—Ä—Ç–∞
                    } else {
                        alert("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞.");
                    }
                } catch (e) {
                    alert("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è JSON: " + e);
                }
            };
            reader.readAsText(file);
            input.value = '';
        }

        // ==========================================
        // 6. Main Logic
        // ==========================================
        async function startProcess() {
            // –ó–∞–∫—Ä—ã–≤–∞–µ–º —Å–∞–π–¥–±–∞—Ä –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
            if (window.innerWidth <= 800 && sidebar.classList.contains('open')) {
                toggleSidebar();
            }

            const btn = document.getElementById('startBtn');
            btn.disabled = true;
            startBtnMobile.disabled = true; // –ë–ª–æ–∫–∏—Ä—É–µ–º –æ–±–µ –∫–Ω–æ–ø–∫–∏

            clearConsole();

            const isTrain = chkTrain.checked;

            // If Generation Only Mode
            if (!isTrain) {
                print("–†–µ–∂–∏–º: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –±–µ–∑ –æ–±—É—á–µ–Ω–∏—è.");
                setStatus("–ó–∞–≥—Ä—É–∑–∫–∞ –≤–µ—Å–æ–≤...");

                if (Object.keys(state_dict).length === 0) {
                    if (!loadFromLocalStorage()) {
                        print("–û—à–∏–±–∫–∞: –í–µ—Å–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –í–∫–ª—é—á–∏—Ç–µ –æ–±—É—á–µ–Ω–∏–µ –∏–ª–∏ –∏–º–ø–æ—Ä—Ç–∏—Ä—É–π—Ç–µ –≤–µ—Å–∞.");
                        btn.disabled = false;
                        startBtnMobile.disabled = false;
                        return;
                    }
                }

                print(`–ú–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞. –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞: Layers=${config.n_layer}, Embd=${config.n_embd}, Heads=${config.n_head}.`);
                await generateNames();
                btn.disabled = false;
                startBtnMobile.disabled = false;
                return;
            }

            // --- Training Mode ---
            print("–†–µ–∂–∏–º: –û–±—É—á–µ–Ω–∏–µ.");

            const newConfig = {
                block_size: parseInt(document.getElementById('inputBlock').value),
                n_embd: parseInt(document.getElementById('inputEmbd').value),
                n_head: parseInt(document.getElementById('inputHeads').value),
                n_layer: parseInt(document.getElementById('inputLayers').value)
            };

            if (newConfig.n_embd % newConfig.n_head !== 0) {
                alert("–û—à–∏–±–∫–∞: –†–∞–∑–º–µ—Ä —ç–º–±–µ–¥–¥–∏–Ω–≥–∞ –¥–æ–ª–∂–µ–Ω –¥–µ–ª–∏—Ç—å—Å—è –Ω–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≥–æ–ª–æ–≤ –±–µ–∑ –æ—Å—Ç–∞—Ç–∫–∞!");
                btn.disabled = false;
                startBtnMobile.disabled = false;
                return;
            }

            seed = parseInt(document.getElementById('inputSeed').value);
            const num_steps = parseInt(document.getElementById('inputSteps').value);
            const learning_rate = parseFloat(document.getElementById('inputLR').value);

            let docs = [];
            setStatus("–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö...");

            const fileInput = document.getElementById('inputFile');
            if (fileInput.files.length > 0) {
                const text = await fileInput.files[0].text();
                docs = text.trim().split('\n').map(l => l.trim()).filter(l => l);
            } else {
                try {
                    const resp = await fetch('https://boolkin.github.io/html/Vibe/microgpt/datasets/dogs.txt');
                    docs = (await resp.text()).trim().split('\n').map(l => l.trim()).filter(l => l);
                } catch (e) {
                    docs = ["emma", "olivia", "ava", "sophia", "isabella", "mia"];
                }
            }

            shuffle(docs);
            print(`–î–∞–Ω–Ω—ã–µ: ${docs.length} –ø—Ä–∏–º–µ—Ä–æ–≤.`);

            const vocab = Array.from(new Set(docs.join(''))).sort();
            const num_params = initModel(vocab, newConfig);
            print(`–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –º–æ–¥–µ–ª–∏: Layers=${config.n_layer}, Embd=${config.n_embd}, Heads=${config.n_head}`);
            print(`–í—Å–µ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤: ${num_params}. –ù–∞—á–∏–Ω–∞–µ–º –æ–±—É—á–µ–Ω–∏–µ...`);

            const beta1 = 0.85, beta2 = 0.99, eps_adam = 1e-8;
            const m = new Array(params.length).fill(0);
            const v = new Array(params.length).fill(0);
            const cc = document.getElementById("ConsoleCount").value;
            for (let step = 0; step < num_steps; step++) {
                const doc = docs[step % docs.length];
                const tokens = [BOS, ...doc.split('').filter(ch => uchars.includes(ch)).map(ch => uchars.indexOf(ch)), BOS];
                const n = Math.min(config.block_size, tokens.length - 1);

                const keys = Array.from({ length: config.n_layer }, () => []);
                const values = Array.from({ length: config.n_layer }, () => []);
                const losses = [];

                for (let pos_id = 0; pos_id < n; pos_id++) {
                    const token_id = tokens[pos_id], target_id = tokens[pos_id + 1];
                    if (target_id < 0 || target_id >= vocab_size) continue;
                    const logits = gpt(token_id, pos_id, keys, values);
                    const probs = softmax(logits);
                    losses.push(probs[target_id].log().mul(-1));
                }

                const loss = sumVals(losses).div(n);
                loss.backward();

                const lr_t = learning_rate * (1 - step / num_steps);

                for (let i = 0; i < params.length; i++) {
                    const p = params[i], grad = p.grad;
                    m[i] = beta1 * m[i] + (1 - beta1) * grad;
                    v[i] = beta2 * v[i] + (1 - beta2) * (grad ** 2);
                    const m_hat = m[i] / (1 - beta1 ** (step + 1));
                    const v_hat = v[i] / (1 - beta2 ** (step + 1));
                    p.data -= lr_t * m_hat / (Math.sqrt(v_hat) + eps_adam);
                    p.grad = 0;
                }

                if ((step + 1) % cc === 0) {
                    print(`step ${step + 1} / ${num_steps} | loss ${loss.data.toFixed(4)}`);
                    setStatus(`–û–±—É—á–µ–Ω–∏–µ... ${step + 1}/${num_steps}`);
                    await new Promise(r => setTimeout(r, 0));
                }
            }

            print("–û–±—É—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ.");
            saveToLocalStorage();

            // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –ø–æ—Å–ª–µ –æ–±—É—á–µ–Ω–∏—è
            chkTrain.checked = false;
            toggleTrainMode();
            openChartModal();
            await generateNames();

            btn.disabled = false;
            startBtnMobile.disabled = false;
        }

        document.getElementById('inputPrefix').value = ""; // –æ—á–∏—Å—Ç–∫–∞ –ø—Ä–µ—Ñ–∏–∫—Å–∞ –ø—Ä–∏ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–µ

        async function generateNames() {
            const temperature = parseFloat(document.getElementById('inputTemp').value);
            const count = parseInt(document.getElementById('inputCount').value);
            const prefixInput = document.getElementById('inputPrefix').value.trim();

            print(`\n--- –ì–µ–Ω–µ—Ä–∞—Ü–∏—è (${count} –∏–º–µ–Ω, T=${temperature}) ---`);
            if (prefixInput) {
                print(`–ü—Ä–µ—Ñ–∏–∫—Å: "${prefixInput}"`);
            }

            function weightedChoice(items, weights) {
                const total = weights.reduce((a, b) => a + b, 0);
                const r = Math.random() * total;
                let sum = 0;
                for (let i = 0; i < items.length; i++) {
                    sum += weights[i];
                    if (r <= sum) return items[i];
                }
                return items[items.length - 1];
            }

            for (let s = 0; s < count; s++) {
                const keys = Array.from({ length: config.n_layer }, () => []);
                const values = Array.from({ length: config.n_layer }, () => []);

                // –ù–∞—á–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
                let token_id = BOS;
                let pos_id = 0;
                const sample = [];

                // === –û–ë–†–ê–ë–û–¢–ö–ê –ü–†–ï–§–ò–ö–°–ê ===
                if (prefixInput) {
                    const validPrefix = [];
                    // –í–∞–ª–∏–¥–∞—Ü–∏—è —Å–∏–º–≤–æ–ª–æ–≤ –ø—Ä–µ—Ñ–∏–∫—Å–∞ –ø–æ —Å–ª–æ–≤–∞—Ä—é
                    for (let ch of prefixInput) {
                        const idx = uchars.indexOf(ch);
                        if (idx !== -1) {
                            validPrefix.push(idx);
                        } else {
                            print(`‚ö† –°–∏–º–≤–æ–ª "${ch}" –Ω–µ –≤ —Å–ª–æ–≤–∞—Ä–µ, –ø—Ä–æ–ø—É—â–µ–Ω`);
                        }
                    }

                    // "–ü—Ä–æ–≥–æ–Ω—è–µ–º" –≤–∞–ª–∏–¥–Ω—ã–π –ø—Ä–µ—Ñ–∏–∫—Å —á–µ—Ä–µ–∑ –º–æ–¥–µ–ª—å –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è KV-–∫—ç—à–∞
                    for (let i = 0; i < validPrefix.length; i++) {
                        if (pos_id >= config.block_size) {
                            print(`‚ö† –ü—Ä–µ—Ñ–∏–∫—Å –æ–±—Ä–µ–∑–∞–Ω –∏–∑-–∑–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è block_size`);
                            break;
                        }
                        // –û–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à –º–æ–¥–µ–ª–∏, –ø–æ–¥–∞–≤–∞—è —Ç–µ–∫—É—â–∏–π —Ç–æ–∫–µ–Ω –Ω–∞ —Ç–µ–∫—É—â–µ–π –ø–æ–∑–∏—Ü–∏–∏
                        gpt(token_id, pos_id, keys, values);
                        // –î–æ–±–∞–≤–ª—è–µ–º —Å–∏–º–≤–æ–ª –ø—Ä–µ—Ñ–∏–∫—Å–∞ –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                        sample.push(uchars[validPrefix[i]]);
                        // –ì–æ—Ç–æ–≤–∏–º—Å—è –∫ —Å–ª–µ–¥—É—é—â–µ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏: —Å–ª–µ–¥—É—é—â–∏–π —Ç–æ–∫–µ–Ω —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –≤—Ö–æ–¥–Ω—ã–º
                        token_id = validPrefix[i];
                        pos_id++;
                    }
                }

                // === –û–°–ù–û–í–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ –ø–æ—Å–ª–µ –ø—Ä–µ—Ñ–∏–∫—Å–∞) ===
                for (; pos_id < config.block_size; pos_id++) {
                    const logits = gpt(token_id, pos_id, keys, values);
                    const scaledLogits = logits.map(l => l.div(temperature));
                    const probs = softmax(scaledLogits);
                    const weights = probs.map(p => p.data);

                    // –°—ç–º–ø–ª–∏—Ä—É–µ–º —Å–ª–µ–¥—É—é—â–∏–π —Ç–æ–∫–µ–Ω
                    const next_token_id = weightedChoice([...Array(vocab_size).keys()], weights);

                    // BOS = –∫–æ–Ω–µ—Ü –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
                    if (next_token_id === BOS) break;

                    sample.push(uchars[next_token_id]);
                    token_id = next_token_id; // –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏
                }

                const result = sample.join('');
                print(`${s + 1}. ${result || '(–ø—É—Å—Ç–æ)'}`);

                // –ù–µ–±–æ–ª—å—à–∞—è –ø–∞—É–∑–∞ –¥–ª—è –æ—Ç–∑—ã–≤—á–∏–≤–æ—Å—Ç–∏ UI
                if (s % 5 === 0) await new Promise(r => setTimeout(r, 0));
            }
        }
    </script>
</body>

</html>